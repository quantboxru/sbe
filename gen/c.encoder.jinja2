{% macro create_group_encoders(prefix, fields) %}
{%     for f in fields if f.type.type == "group" %}
   {{package}}_group_encoder_t {{prefix}}_{{f.name}}_grp_encoder;
{{create_group_encoders(prefix+"_"+f.name, f.fields)-}}
{%     endfor %}
{% endmacro -%}

{% macro create_field(f) %}
{%    if f.type.type == "simple" %}
{%       if f.type.length > 1 %}
   {{f.type|c_type}} {{f.name}}[{{f.type.length}}];
{%       else %}
   {{f.type|c_type}} {{f.name}};
{%       endif %}
{%    elif f.type.type == "enum" %}
   {{package}}_{{f.type.name}}_t {{f.name}};
{%    elif f.type.type == "composite" %}
   {{f.type|c_type}}_t {{f.name}};
{%    endif %}
{% endmacro -%}

{% macro create_group_structs(prefix, fields) %}
{%     for g in fields if g.type.type == "group" %}
typedef struct
{
{%       for f in g.fields %}
{{create_field(f)-}}
{%       endfor %}
} {{prefix}}_{{g.name}}_t;

{{create_group_structs(prefix+"_"+g.name, g.fields)-}}
{%    endfor %}
{% endmacro -%}
/**
  * @brief CAUTION: do not change this file - it is autogenerated.
  */

#include "{{env.header}}"
#include <common/xroad_aux.h>
#include <math.h>

typedef struct
{
   uint16_t block_length;
   uint16_t template_id;
   uint16_t schema_id;
   uint16_t version;
} message_header_t;

typedef struct
{
   uint16_t block_length;
   uint16_t num_in_group;
} group_size_encoding_t;

typedef struct
{
   {{package}}_templates_t tid;
   char* data;
   size_t len;
   {{package}}_logger_cback_t cback;
   size_t var_offset;
} encoder_t;

struct {{package}}_group_encoder_s
{
   void* encoder;
   uint16_t idx;
   char* data;
};

typedef struct {{package}}_group_encoder_s {{package}}_group_encoder_t;

struct {{package}}_default_encoder_s
{
   encoder_t* base;
};

{% for m in messages if m|has_groups %}
struct {{package}}_{{m.name}}_encoder_s
{
   encoder_t base;
{{create_group_encoders(m.name, m.fields)-}}
};
{% endfor %}

// groups

{% for m in messages %}
{{create_group_structs(m.name, m.fields)-}}
{% endfor -%}

// messages

{% for m in messages %}
typedef struct
{
{% for f in m.fields if f.type.presence != "constant" %}
{{create_field(f)-}}
{% endfor %}
} {{m.name}}_t;

{% endfor -%}

{#% macro render_fields(m, e, prefix, is_grp) -%}
{%    for f in e.fields if f.type.presence != "constant" %}
{%        if f.type.type in ["simple", "enum"] %}
//--------------------------------------------------------------------------------------------------------------------//
{%            if f.type.type == "simple"  %}
int32_t {{package}}_{{prefix}}_set_{{f.name}}({{package}}_{{prefix}}_encoder_t* e, {{f.type|c_type_decl}} val)
{%            elif f.type.type == "enum"  %}
int32_t {{package}}_{{prefix}}_set_{{f.name}}({{package}}_{{prefix}}_encoder_t* e, {{package}}_{{f.type.name}}_t val)
{%            endif  %}
{
{%            if is_grp == false %}
   encoder_t* base = &e->base;
   {{e.name}}_t* obj = ({{e.name}}_t*)(base->data + base->var_offset + sizeof(message_header_t));
{%            else %}
   encoder_t* base = (encoder_t*)e->encoder;
   group_size_encoding_t* grp_dim = (group_size_encoding_t*)e->data;
   {{prefix}}_t* obj = ({{prefix}}_t*)(e->data + sizeof(group_size_encoding_t) +
                                       base->var_offset - (grp_dim->num_in_group - e->idx) * 16);
{%            endif %}
{%            if f.type.length > 1 and f.type.primitive_type == "char" %}
   if (val.len > {{f.type.length}} && base->cback)
   {
      (base->cback)({{package}}_log_level_warn, "data is too long for {{e.name}}_{{f.name}} field and will be truncated");
   }
   memcpy(obj->{{f.name}}, val.data, xroad_min(val.len, {{f.type.length}}));
{%            else %}
   obj->{{f.name}} = val;
{%            endif %}
   return 0;
}

{%            if f.type.presence == "optional" %}
//--------------------------------------------------------------------------------------------------------------------//
void {{package}}_{{prefix}}_reset_{{f.name}}({{package}}_{{prefix}}_encoder_t* e)
{
{%                if is_grp == false %}
   encoder_t* base = &e->base;
   {{e.name}}_t* obj = ({{e.name}}_t*)(base->data + base->var_offset + sizeof(message_header_t));
{%                else %}
   encoder_t* base = (encoder_t*)e->encoder;
   group_size_encoding_t* grp_dim = (group_size_encoding_t*)e->data;
   {{prefix}}_t* obj = ({{prefix}}_t*)(e->data + sizeof(group_size_encoding_t) +
                                       base->var_offset - (grp_dim->num_in_group - e->idx) * 16);
{%                endif %}
{%                if f.type.length > 1 and f.type.primitive_type == "char" %}
   memcpy(obj->{{f.name}}, "{{f.type.null_value}}", xroad_min(strlen("{{f.type.null_value}}"), {{f.type.length}}));
{%               elif f.type.primitive_type in ["double", "float"] and f.type.null_value == "nan" %}
   obj->{{f.name}} = NAN;
{%                else %}
   obj->{{f.name}} = {{f.type.null_value}};
{%                endif %}
}

{%            endif %}
{%        elif f.type.type == "data" and f.type.name == "varString" %}
//--------------------------------------------------------------------------------------------------------------------//
int32_t {{package}}_{{prefix}}_set_{{f.name}}({{package}}_{{prefix}}_encoder_t* e, {{f.type|c_type_decl}} val)
{
   if (sizeof(message_header_t) + {{e.size}} + e->base.var_offset + val.len > e->base.len && e->base.cback)
   {
      (e->base.cback)({{package}}_log_level_warn, "no more buffer space for encode {{f.name}} field in {{e.name}}");
      return -1;
   }
{%                if is_grp == false %}
   encoder_t* base = &e->base;
   var_string_t* obj = (var_string_t*)(base->data + sizeof(message_header_t) + {{f.offset}} + base->var_offset);
{%                else %}
   encoder_t* base = (encoder_t*)e->encoder;
   group_size_encoding_t* grp_dim = (group_size_encoding_t*)e->data;
   var_string_t* obj = ({{prefix}}_t*)(e->data + sizeof(group_size_encoding_t) +
                              base->var_offset - (grp_dim->num_in_group - e->idx) * 16) + {{f.offset}};
{%                endif %}
   obj->length = val.len;
   memcpy(obj->data, val.data, val.len);
   base->var_offset += val.len;
   return 0;
}

{%        elif f.type.type == "composite" %}
//--------------------------------------------------------------------------------------------------------------------//
{{package}}_{{f.type.name}}_encoder_t* {{package}}_{{prefix}}_get_{{f.name}}_encoder({{package}}_{{prefix}}_encoder_t* e)
{
{%                if is_grp == false %}
   encoder_t* base = e->base;
   {{e.name}}_t* obj = ({{e.name}}_t*)(base->data + sizeof(message_header_t));
{%                else %}
   encoder_t* base = (encoder_t*)e->encoder;
   group_size_encoding_t* grp_dim = (group_size_encoding_t*)e->data;
   {{prefix}}_t* obj = ({{prefix}}_t*)(e->data + sizeof(group_size_encoding_t) +
                              base->var_offset - (grp_dim->num_in_group - e->idx) * 16) + {{f.offset}};
{%                endif %}
   return &obj->{{f.name}};
}
%            for t in f.type.types if t.type in ["simple", "enum"] and t.presence != "constant" %}
//--------------------------------------------------------------------------------------------------------------------//
int32_t {{package}}_{{prefix}}_set_{{f.name}}_{{t.name}}({{package}}_{{prefix}}_encoder_t* e, {{t|c_type_decl}} val)
{
{%                if is_grp == false %}
   encoder_t* base = &e->base;
   {{e.name}}_t* obj = ({{e.name}}_t*)(base->data + sizeof(message_header_t));
{%                else %}
   encoder_t* base = (encoder_t*)e->encoder;
   group_size_encoding_t* grp_dim = (group_size_encoding_t*)e->data;
   {{prefix}}_t* obj = ({{prefix}}_t*)(e->data + sizeof(group_size_encoding_t) +
                              base->var_offset - (grp_dim->num_in_group - e->idx) * 16) + {{f.offset}};
{%                endif %}
{%                if t.length > 1 and t.primitive_type == "char" %}
   if (val.len > {{t.length}} && base->cback)
   {
      (base->cback)({{package}}_log_level_warn, "data is too long for {{e.name}}_{{f.name}}_{{t.name}} field and will be truncated");
   }
   memcpy(obj->{{f.name}}.{{t.name}}, val.data, xroad_min(val.len, {{t.length}}));
{%                else %}
   obj->{{f.name}}.{{t.name}} = val;
{%                endif %}
   return 0;
}

{%            endfor %}
{%        elif f.type.type == "group" %}
//--------------------------------------------------------------------------------------------------------------------//
{{package}}_{{prefix}}_{{f.name}}_encoder_t* {{package}}_{{prefix}}_add_{{f.name}}({{package}}_{{prefix}}_encoder_t* e, uint16_t num)
{
{%            if is_grp == false %}
   group_size_encoding_t* grp_dim = (group_size_encoding_t*)(e->base.data + e->base.var_offset + {{f.offset}});
{%            else %}
   {{package}}_{{m.name}}_encoder_t* encoder = ({{package}}_{{m.name}}_encoder_t*)e->encoder;
   group_size_encoding_t* grp_dim = (group_size_encoding_t*)e->data;
{%            endif %}
   grp_dim->block_length = {{f.size}};
   grp_dim->num_in_group = num;
{%            if is_grp == false %}
   e->{{prefix}}_{{f.name}}_grp_encoder.encoder = e;
   e->{{prefix}}_{{f.name}}_grp_encoder.data = e->base.data + e->base.var_offset + {{f.offset}};
   e->base.var_offset += num * 16;
   return &e->{{prefix}}_{{f.name}}_grp_encoder;
{%            else %}
   encoder->{{prefix}}_{{f.name}}_grp_encoder.encoder = encoder;
   encoder->{{prefix}}_{{f.name}}_grp_encoder.data = encoder->base.data + encoder->base.var_offset + {{f.offset}};
   encoder->base.var_offset += num * 16;
   return &encoder->{{prefix}}_{{f.name}}_grp_encoder;
{%            endif %}
}

//--------------------------------------------------------------------------------------------------------------------//
uint16_t {{package}}_{{prefix}}_{{f.name}}_encode_get_idx({{package}}_{{prefix}}_{{f.name}}_encoder_t* e)
{
   return e->idx;
}

//--------------------------------------------------------------------------------------------------------------------//
{{package}}_{{prefix}}_{{f.name}}_encoder_t* {{package}}_{{prefix}}_{{f.name}}_encode_next({{package}}_{{prefix}}_{{f.name}}_encoder_t* e)
{
   group_size_encoding_t* grp_dim = (group_size_encoding_t*)e->data;
   e->idx += 1; // increment index
   if (e->idx == grp_dim->num_in_group)
   {
      return NULL;
   }
   return e;
}

{{            render_fields(m, f, prefix+"_"+f.name, true)-}}
{%        endif %}
{%    endfor %}
{% endmacro -%#}

{% macro set_composite_defaults(ptr, types) %}
{%    for t in types if t.presence == "optional" or t.type == "composite" %}
{%       if t.type in ["simple", "enum"] %}
{%          if t.length > 1 and t.primitive_type == "char" %}
         memcpy({{ptr}}.{{t.name}}, "{{t.null_value}}", xroad_min(strlen("{{t.null_value}}"), {{t.length}}));
{%          elif t.primitive_type in ["double", "float"] and t.null_value == "nan" %}
         {{ptr}}.{{t.name}} = NAN;
{%          else %}
         {{ptr}}.{{t.name}} = {{t.null_value}};
{%          endif %}
{%       elif t.type == "composite" %}
{{set_composite_defaults(ptr+"."+t.name, t.types)-}}
{%       endif %}
{%    endfor %}
{% endmacro %}

//--------------------------------------------------------------------------------------------------------------------//
void* {{package}}_create_encoder({{package}}_templates_t tid, char* data, size_t len, {{package}}_logger_cback_t cback)
{
   switch(tid)
   {
{% for m in messages %}
      case {{package}}_template_{{m.name}}:
      {
         if (len < sizeof(message_header_t) + {{m.size}})
         {
            if (cback)
            {
               cback({{package}}_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         {{package}}_{{m.name}}_encoder_t* encoder = calloc(1, sizeof({{package}}_{{m.name}}_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = {{schema_id}};
         hdr->version = {{version}};
         hdr->block_length = {{m.size}};
{%       if m|has_optional %}
         {{m.name}}_t* msg = ({{m.name}}_t*)(encoder->base.data + sizeof(message_header_t));
{%          for f in m.fields if f.type.presence == "optional" %}
{%             if f.type.length > 1 and f.type.primitive_type == "char" %}
         memcpy(msg->{{f.name}}, "{{f.type.null_value}}", xroad_min(strlen("{{f.type.null_value}}"), {{f.type.length}}));
{%             else %}
         msg->{{f.name}} = {{f.type.null_value}};
{%             endif %}
{%           endfor %}
{%       endif %}
         return encoder;
      }
{% endfor %}
      default:
      {
         if (cback)
         {
            cback({{package}}_log_level_error, "unknown template id");
         }
         return NULL;
      }
   }
}

//--------------------------------------------------------------------------------------------------------------------//
void {{package}}_destroy_encoder(void* encoder)
{
   free(encoder);
}

{% for m in messages %}
//--------------------------------------------------------------------------------------------------------------------//
int32_t {{package}}_{{m.name}}_get_size({{package}}_{{m.name}}_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

{#{{render_fields(m, m, m.name, false)-}}#}
{% endfor %}
