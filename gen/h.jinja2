{# 
//--------------------------------------------------------------------------------------------------------------------//
Encoder macros
//--------------------------------------------------------------------------------------------------------------------//
#}

{% macro render_encoding_fields(name, fields) -%}
{%    for f in fields if f.type.presence != "constant" %}
{%       if f.type.type == "simple" %}
{%          if f.type.length != 1 %}
void {{name}}_set_{{f.name}}({{name}}_encoder_t* e, const {{f.type|c_type}}* val, size_t len);
{%          else %}
void {{name}}_set_{{f.name}}({{name}}_encoder_t* e, {{f.type|c_type_decl}} val);
{%          endif %}

{%          if f.type.presence == "optional" %}
void {{name}}_reset_{{f.name}}({{name}}_encoder_t* e);

{%          endif %}
{%       elif f.type.type == "enum" %}
int32_t {{name}}_set_{{f.name}}({{name}}_encoder_t* e, {{package}}_{{f.type.name}}_t val);

{%          if f.type.presence == "optional" %}
void {{name}}_reset_{{f.name}}({{name}}_encoder_t* e);

{%          endif %}
{%       elif f.type.type == "group" %}
{{name}}_{{f.name}}_encoder_t* {{name}}_add_{{f.name}}({{name}}_encoder_t* e, uint16_t num);

{{name}}_{{f.name}}_encoder_t* {{name}}_{{f.name}}_encode_next({{name}}_{{f.name}}_encoder_t* e);

uint16_t {{name}}_{{f.name}}_encode_get_idx({{name}}_{{f.name}}_encoder_t* e);

{{             render_encoding_fields(name+"_"+f.name, f.fields) -}}
{%       elif f.type.type == "data" %}
void {{name}}_set_{{f.name}}({{name}}_encoder_t* e, const {{f.dimension_type.data_type|c_type}}* val, size_t len);

{%       endif %}
{%    endfor %}
{% endmacro -%}

{% macro typedef_group_encoders(prefix, fields) %}
{%     for f in fields if f.type.type == "group" %}
typedef struct {{package}}_group_encoder_t {{prefix}}_{{f.name}}_encoder_t;

{{           typedef_group_encoders(prefix+"_"+f.name, f.fields)-}}
{%     endfor %}
{% endmacro -%}

{# 
//--------------------------------------------------------------------------------------------------------------------//
Decoder macros
//--------------------------------------------------------------------------------------------------------------------//
#}

{% macro typedef_group_decoders(prefix, fields) %}
{%     for f in fields if f.type.type == "group" %}
typedef struct {{package}}_group_decoder_t {{prefix}}_{{f.name}}_decoder_t;

{{           typedef_group_decoders(prefix+"_"+f.name, f.fields)-}}
{%     endfor %}
{% endmacro -%}


{% macro render_decoding_fields(name, fields) -%}
{%    for f in fields %}
{%        if f.type.type == "simple" %}
{{f.type|c_type_decl}} {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%            if f.type.presence == "optional" %}
bool {{name}}_{{f.name}}_is_null({{name}}_decoder_t* d);

{%            endif %}
{%        elif f.type.type == "enum" %}
{{package}}_{{f.type.name}}_t {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%        elif f.type.type == "builtin" %}
{{f.type|c_type_decl}} {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%        elif f.type.type == "composite" %}
{%            for t in f.type.types %}
{{t|c_type_decl}} {{name}}_get_{{f.name}}_{{t.name}}({{name}}_decoder_t* d);

{%            endfor %}
{%        elif f.type.type == "group" %}
{{name}}_{{f.name}}_decoder_t* {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{{name}}_{{f.name}}_decoder_t* {{name}}_{{f.name}}_decode_next({{name}}_{{f.name}}_decoder_t* d);

uint16_t {{name}}_{{f.name}}_decode_get_idx({{name}}_{{f.name}}_decoder_t* d);

size_t {{name}}_{{f.name}}_decode_get_count({{name}}_{{f.name}}_decoder_t* d);

{{             render_decoding_fields(name+"_"+f.name, f.fields) -}}
{%        elif f.type.type == "data" %}
xroad_str_t {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%        endif %}
{%    endfor %}
{% endmacro -%}

{#
//--------------------------------------------------------------------------------------------------------------------//
Generated file
//--------------------------------------------------------------------------------------------------------------------//
#}

/**
  * @brief CAUTION: do not change this file - it is autogenerated.
  */

#pragma once

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

#ifdef __cplusplus
extern "C"
{
#endif


#define SBE_INT8_NULL       (-128)      // 0x80
#define SBE_UINT8_NULL      255         // 0xFF
#define SBE_INT16_NULL      (-32768)    // 0x8000
#define SBE_UINT16_NULL     65535       // 0xFFFF
#define SBE_INT32_NULL      (-2147483647-1) // 0x80000000
#define SBE_UINT32_NULL     0xFFFFFFFFU     // 0xFFFFFFFF
#define SBE_INT64_NULL      (-0x7FFFFFFFFFFFFFFFLL-1) // 0x8000000000000000
#define SBE_UINT64_NULL     0xFFFFFFFFFFFFFFFFULL     // 0xFFFFFFFFFFFFFFFF
#define SBE_FLOAT_NULL      NAN
#define SBE_DOUBLE_NULL     NAN
#define SBE_CHAR_NULL       '\0'


#define xroad_min(a,b) (((a)<(b))?(a):(b))


typedef struct xroad_str_t
{
  size_t len;
  char* data;
} xroad_str_t;


typedef enum
{
   {{package}}_log_level_error  = 1,
   {{package}}_log_level_warn   = 2,
   {{package}}_log_level_notice = 4,
   {{package}}_log_level_info   = 8,
   {{package}}_log_level_debug  = 16,
   {{package}}_log_level_trace  = 32
} {{package}}_log_level_t;


typedef enum
{
{% for m in messages %}
   {{package}}_template_{{m.name}} = {{m.id}},
{% endfor %}
} {{package}}_templates_t;

{% for t in types if t.type == "enum" %}
{%    if t.description %}
// {{t.description}}
{%    endif %}
typedef enum
{
{%    for e in t.entries %}
   {{package}}_{{t.name}}_{{e.name}} = {%if t.encoding_type == "char"%}'{{e.value}}'{% else %}{{e.value}}{% endif %},{%if e.description%} // {%endif%}{{e.description}}
{%    endfor %}
} {{package}}_{{t.name}}_t;

{% endfor -%}

//--------------------------------------------------------------------------------------------------------------------//
// encoding types

{% for m in messages %}
struct {{package}}_{{m.name}}_encoder_t;

typedef struct {{package}}_{{m.name}}_encoder_t {{package}}_{{m.name}}_encoder_t;

{% endfor -%}

struct {{package}}_group_encoder_t;

{% for m in messages %}
{{-typedef_group_encoders(package+"_"+m.name, m.fields)-}}
{% endfor -%}

// encoder

void* {{package}}_encoder_create({{package}}_templates_t id, char* data, size_t len);

void {{package}}_encoder_destroy(void* encoder);

{% for m in messages %}
// {{m.name}} encoder

size_t {{package}}_{{m.name}}_encoder_get_encoded_length({{package}}_{{m.name}}_encoder_t* e);

{{ render_encoding_fields(package+"_"+m.name, m.fields) -}}
{% endfor %}

//--------------------------------------------------------------------------------------------------------------------//
// decoding types

{% for m in messages %}
struct {{package}}_{{m.name}}_decoder_t;

typedef struct {{package}}_{{m.name}}_decoder_t {{package}}_{{m.name}}_decoder_t;

{% endfor -%}

struct {{package}}_group_decoder_t;

{% for m in messages %}
{{-typedef_group_decoders(package+"_"+m.name, m.fields)-}}
{% endfor -%}

// decoder

void* {{package}}_decoder_create(char* data, size_t len);

void {{package}}_decoder_destroy(void* decoder);

{% for m in messages %}
// {{m.name}} decoder

size_t {{package}}_{{m.name}}_decoder_get_decoded_length({{package}}_{{m.name}}_decoder_t* d);

{{-render_decoding_fields(package+"_"+m.name, m.fields)-}}
{% endfor %}

#ifdef __cplusplus
}
#endif
